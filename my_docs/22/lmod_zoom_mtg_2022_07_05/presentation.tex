\documentclass{beamer}

% You can also use a 16:9 aspect ratio:
%\documentclass[aspectratio=169]{beamer}
\usetheme{TACC16}

% It's possible to move the footer to the right:
%\usetheme[rightfooter]{TACC16}

%% page 
%\begin{frame}{}
%  \begin{itemize}
%    \item
%  \end{itemize}
%\end{frame}
%
%% page 
%\begin{frame}[fragile]
%    \frametitle{}
% {\tiny
%    \begin{semiverbatim}
%    \end{semiverbatim}
%}
%  \begin{itemize}
%    \item
%  \end{itemize}
%
%\end{frame}

\begin{document}
\title[Lmod]{How Lmod Loads a Modulefile, Part 2}
\author{Robert McLay} 
\date{July. 5, 2022}

% page 1
\frame{\titlepage} 


% page 2
\begin{frame}{Outline}
  \center{\includegraphics[width=.9\textwidth]{Lmod-4color@2x.png}}
  \begin{itemize}
    \item Part 1 took us to Master:load() and loadModuleFile(t)
    \item This part will start with Master:load() and loadModuleFile(t)
    \item This talk will be about handing off your modulefile to the
      Lua interpreter and Lmod routines.
  \end{itemize}
\end{frame}

% page 3
\begin{frame}[fragile]
    \frametitle{Outline (II)}
  \begin{itemize}
    \item \texttt{main()}: How main() parses the command line
    \item \texttt{...}
    \item \texttt{Master:load(mA)}: Where the heavy lifting is done
    \item \texttt{loadModuleFile()}: Where the modulefile is actually evaluated
  \end{itemize}
\end{frame}

% page 4
\begin{frame}[fragile]
    \frametitle{\texttt{Master:load()}: getting ready to call loadModuleFile(t)}
  \begin{itemize}
    \item src: src/Master.lua
    \item There is no duplicate sn so we can load the modulefile {\color{blue}\emph{foo}}.
  \end{itemize}
 {\tiny
    \begin{semiverbatim}
elseif (fn) then
   frameStk:push(mname)
   mt = frameStk:mt()
   mt:add(mname,"pending")
   local status = loadModuleFile\{file = fn, shell = shellNm,
                   mList = mList, reportErr = true\}
   -- part 2

    \end{semiverbatim}
}
\end{frame}

% page 5
\begin{frame}[fragile]
    \frametitle{After loading modulefile}
 {\tiny
    \begin{semiverbatim}
     -- Now fn is loaded 

     mt = frameStk:mt() -- Why?

     -- A modulefile could the same named module over top of the current modulefile
     -- Say modulefile abc/2.0 loads abc/.cpu/2.0.  Then in the case of abc/2.0 the filename
     -- won't match.
     if (mt:fn(sn) == fn and status) then
        mt:setStatus(sn, "active")
        hook.apply("load",{fn = mname:fn(), modFullName = mname:fullName(), mname = mname})
     end
     frameStk:pop()
     loaded = true
    \end{semiverbatim}
}
\end{frame}

% page 6
\begin{frame}{Notes about loadModuleFile(t) function}
  \begin{itemize}
    \item Almost all commands will eval one or more modules
    \item Does not: module list, module -t avail
    \item Does:   module load, module unload, module help, module whatis, ...
    \item Even if your site uses a system spider cache, you will re-eval modulefiles that change \$MODULEPATH (New)
  \end{itemize}
\end{frame}

% page 7
\begin{frame}[fragile]
    \frametitle{Let's load the modulefile w/ \texttt{loadModuleFile(t)}}
 {\tiny
    \begin{semiverbatim}
function loadModuleFile(t)
   ----------------------------------------------------------------------
   -- Don't complain if t.file has disappeared when mode() == "unload"
   ----------------------------------------------------------------------
   -- Check for infinite loop on mode() == "load"
   ----------------------------------------------------------------------
   -- Read modulefile into string "whole"

   if (t.ext == ".lua") then
      -- Read complete Lua modulefile into "whole"
   else
      -- Convert TCL modulefile into Lua
   end

   ----------------------------------------------------------------------
   -- Use sandbox to evaluate modulefile

   ----------------------------------------------------------------------
   -- Report any errors and error out

   ----------------------------------------------------------------------
   -- Mark lmodBrk is LmodBreak() is called inside moduleFile
   return not lmodBrk
end
    \end{semiverbatim}
}
  \begin{itemize}
    \item Note that we passed an anonymous table in Master.lua.   
    \item The result is that there is a single argument "t" to the function.
  \end{itemize}

% page 8
\begin{frame}[fragile]
    \frametitle{Reading entire modulefile}
 {\tiny
    \begin{semiverbatim}
    if (t.ext == ".lua") then
      -- Read in lua module file into a [[whole]] string.
      local f = io.open(t.file)
      if (f) then
         whole = f:read("*all")
         f:close()
      end
   \end{semiverbatim}
}
\end{frame}

% page 9
\begin{frame}{Converting TCL to Lua} 
  \begin{itemize}
    \item This will be another talk. But TL; DR
    \item The TCL interpreter run on the TCL modulefile
    \item But \texttt{setenv FOO BAR} is converted to the string
      \texttt{setenv("FOO","BAR")}
    \item \texttt{prepend-path PATH /...} $\Rightarrow$
      \texttt{prepend_path("PATH","/..."}
    \item etc
  \end{itemize}
\end{frame}

% page 10
\begin{frame}[fragile]
    \frametitle{TCL conversion example}
 {\tiny
   \begin{semiverbatim}
---------- Input: -----------------

global env
proc ModulesHelp { } {
puts stderr "Help message..."
}
set modulepath\_root  \$env(MODULEPATH\_ROOT)
set moduleshome     "\$modulepath\_root/TACC"

module load Linux
module try-add cluster
module load TACC-paths

---------- Output: -----------------

load("Linux")
try_load("cluster")
load("TACC-paths")
    \end{semiverbatim}
}
\end{frame}


% page 11
\begin{frame}{What is the sandbox?}
  \begin{itemize}
    \item Lua offers the ability to evaluate a string containing Lua
      code
    \item \emph{WITH} the possibility of a limited choice of
      functions.
    \item Otherwise your modulefiles could accidentally run my Lmod
      internal routines.
    \item I did this once testing Lmod and realized the problem.
    \item Sites may run their own special function
    \item BUT: They must be registered with the sandbox 
    \item Sites can use the SitePackage.lua or
      /etc/lmod/lmod\_config.lua to register their own functions
  \end{itemize}
\end{frame}

% page 12
\begin{frame}[fragile]
    \frametitle{status, msg = sandbox\_run(whole)}
 {\tiny
    \begin{semiverbatim}
local function l\_run5\_2(untrusted\_code)
  local untrusted\_function, message = load(untrusted\_code, nil, 't', sandbox\_env)
  if not untrusted\_function then return nil, message end
  return pcall(untrusted\_function)
end

--------------------------------------------------------------------------
-- Define two version: Lua 5.1 or 5.2.  It is likely that
-- The 5.2 version will be good for many new versions of
-- Lua but time will only tell.
sandbox\_run = (\_VERSION == "Lua 5.1") and l\_run5\_1 or l\_run5\_2
    \end{semiverbatim}
}
\end{frame}


% page 13
\begin{frame}[fragile]
    \frametitle{What is sandbox\_env (src/sandbox.lua?}
 {\tiny
    \begin{semiverbatim}
local sandbox\_env = \{
  assert   = assert,
  loadfile = loadfile,
  require  = require,
  ipairs   = ipairs,
  next     = next,
  pairs    = pairs,
  pcall    = pcall,
  tonumber = tonumber,
  tostring = tostring,
  type     = type,
  load      = load\_module,
  load\_any = load\_any,

  --- PATH functions ---
  prepend\_path         = prepend\_path,
  append\_path          = append\_path,
  remove\_path          = remove\_path,

  --- Set Environment functions ----
  setenv               = setenv,
  pushenv              = pushenv,
  unsetenv             = unsetenv,

  ...
\}
    \end{semiverbatim}
}
  \begin{itemize}
    \item Modulefiles can only execute functions in sandbox\_env
  \end{itemize}
\end{frame}





% page 9
\begin{frame}[fragile]
    \frametitle{}
  \begin{itemize}
    \item All functions implementing user commands are in src/cmdfunc.lua
  \end{itemize}

 {\tiny
    \begin{semiverbatim}
function Load\_Try(...)
   dbg.start\{"Load\_Try(",concatTbl(\{...\},", "),")"\}
   local check\_must\_load = false
   local argA            = pack(...)
   l\_usrLoad(argA, check\_must\_load)
   dbg.fini("Load\_Try")
end

function Load\_Usr(...)
   dbg.start\{"Load\_Usr(",concatTbl(\{...\},", "),")"\}
   local check\_must\_load = true
   local argA            = pack(...)
   l\_usrLoad(argA, check\_must\_load)
   dbg.fini("Load\_Usr")
end
    \end{semiverbatim}
}
\end{frame}

% page 9
\begin{frame}[fragile]
    \frametitle{l\_usrLoad(argA, check\_must\_load)}
  \begin{itemize}
    \item Split argA into loads in lA, unloads in uA (-foo)
    \item Both uA and lA are an array of MName objects.
    \item unload modules in uA 
    \item {\color{blue} \texttt{lA[\#lA+1] = MName:new("load",module\_name)}}
    \item {\color{blue} \texttt{mcp:load\_usr(lA)}}
    \item src: src/cmdfunc.lua
  \end{itemize}
\end{frame}

% page 10
\begin{frame}[fragile]
    \frametitle{MName class: Module Name class}
 {\tiny
    \begin{semiverbatim}
    \end{semiverbatim}
}
  \begin{itemize}
    \item Maps name (``foo'' or ``foo/1.1'') to filename
    \item There are two kinds of searching ``load'' or ``mt''
    \item Load: must search file system. 
    \item mt: filename is in moduletable
    \item Evaluation must be lazy or just-in-time
    \item Software hierarchy means that 
    \item {\color{blue}\texttt{module load gcc mpich}}
    \item mpich might not be in \$MODULEPATH until after gcc is loaded
    \item src: src/MName.lua
  \end{itemize}

\end{frame}

% page 11
\begin{frame}{MName key concepts}
  \begin{itemize}
    \item \textbf{userName}: name on the command line
    \item It might be gcc or gcc/9.3.0
    \item \textbf{sn}: the shortName or a name without a version
    \item \textbf{fullName}: The full name of the module (sn/version)
    \item Examples:
      \begin{enumerate}
        \item gcc/9.3.0 (sn: gcc, N/V)
        \item gcc/x86\_64/9.3.0 (sn: gcc, N/V/V)
        \item compiler/gcc/9.3.0 (sn: compiler/gcc, C/N/V)
        \item compiler/gcc/x86\_64/9.3.0 (sn: compiler/gcc, N/V/V)
      \end{enumerate}
  \end{itemize}
\end{frame}

% page 12
\begin{frame}[fragile]
    \frametitle{mcp and MasterControl class}
  \begin{itemize}
    \item MasterControl class is what controls whether a "load" in a
      modulefile is a load or unload
    \item mcp is a global variable that is built to be in a mode()
      like load, unload, spider, etc.
    \item We talked about this in an earlier presentation.
  \end{itemize}
\end{frame}

% page 13
\begin{frame}[fragile]
    \frametitle{MasterControl:load(mA)}
 {\tiny
    \begin{semiverbatim}
function M.load(self, mA)
   local master = Master:singleton()
   local a      = master:load(mA)

   if (not quiet()) then
      self:registerAdminMsg(mA) -- nag msg registration.
   end
   return a
end
    \end{semiverbatim}
}
  \begin{itemize}
    \item MasterControl functions call Master Functions to do the work.
    \item src: src/MasterControl.lua
  \end{itemize}
\end{frame}

% page 14
\begin{frame}[fragile]
    \frametitle{Master:load(mA)}
 {\tiny
    \begin{semiverbatim}
function M.load(mA)
  for i = 1, #mA do
     repeat
        mname = mA[i]
        sn = mname:sn()  -- shortName
        fn = mname:fn()  -- file name
        -- if blank sn -> pushModule (might have to wait until
        -- compiler or mpi is loaded.
        -- and break (really continue)

        if (mt:have(sn,"active)) then
           -- Block 1: Check for previously loaded module with same sn

        elseif (fn) then
           -- Block 2: Load modulefile

        -- Check for family stack (e.g. compiler, mpi etc)
        if (mcp.processFamilyStack(fullName)) then
            -- Suppose gcc is loaded and it was "replaced" by intel
            -- unload gcc and reload intel
         end
      until true
   end         
     
   -- Reload every module if change in MODULEPATH.
     
   -- load any modules on module stack
end
    \end{semiverbatim}
}
  \begin{itemize}
    \item This is where the heavy lifting is done.
    \item src: src/Master.lua
  \end{itemize}

\end{frame}

% page 15
\begin{frame}[fragile]
    \frametitle{Block 1: Check for previous loaded module w/same sn}
 {\tiny
    \begin{semiverbatim}
 if (mt:have(sn,"active)) then
    -- if disable_same_name_autoswap -> error out
    -- Otherwise: unload previous module
     local mcp_old = mcp
     local mcp     = MCP
     unload_internal\{MName:new("mt",sn)\}
     mname:reset()  -- force a new lazyEval
     local status = mcp:load_usr\{mname\}
     mcp          = mcp_old
    \end{semiverbatim}
}
  \begin{itemize}
    \item Here we guarantee the right mcp
    \item Unload the old module 
    \item Recursively mcp:load\_usr{mname} 
  \end{itemize}
\end{frame}

% page 16
\begin{frame}[fragile]
    \frametitle{Block 2: Load modulefile}
 {\tiny
    \begin{semiverbatim}
elseif (fn) then
   frameStk:push(mname)
   mt = frameStk:mt()
   mt:add(mname,"pending")
   local status = loadModuleFile\{file = fn, shell = shellNm,
                   mList = mList, reportErr = true\}
   frameStk:pop()
   loaded = true
end
    \end{semiverbatim}
}
\end{frame}

% page 17
\begin{frame}[fragile]
    \frametitle{loadModuleFile(t)}
  \begin{itemize}
    \item This is where Lmod handle either *.lua files or TCL Modulefiles
    \item Once either read in as a block (for *.lua) or converted (TCL
      modulefile $\Rightarrow$ Lua)
    \item src: src/loadModulefile.lua
  \end{itemize}
 {\tiny
    \begin{semiverbatim}
   -- Use the sandbox to evaluate modulefile text.
   if (whole) then
      status, msg = sandbox_run(whole)
   else
      status = nil
      msg    = "Empty or non-existent file"
   end
   -- report any errors
    \end{semiverbatim}
}

\end{frame}

% page 18
\begin{frame}{Next time}
  \begin{itemize}
    \item What is a sandbox and how does it work?
    \item Why I want a sandbox?
    \item Next time handing control to modulefile
  \end{itemize}
\end{frame}



% page 19
\begin{frame}{Conclusions}
  \begin{itemize}
    \item It takes a lot to get to the point where Lmod is evaluating
      your modulefile.
    \item Lmod uses several ``classes'' to manage the loading of a
      module
    \item Plus a couple of Design Patterns such as Singletons  
  \end{itemize}
\end{frame}

% page 20
\begin{frame}{Future Topics}
  \begin{itemize}
    \item Next Meeting: July 5th 9:30 US Central (14:30 UTC)
    \item What happens from the loadModulefile(t).
    \item This is where Lmod hands off control to the user.
  \end{itemize}
\end{frame}

\end{document}
