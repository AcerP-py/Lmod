This is the second half of what Lmod does to load a module.

* Part 1 took us to a section of code in Master.lua M.load (AKA Master:load())
** We are now read to use the loadModuleFile(): 

  elseif (fn) then
     local mList = concatTbl(mt:list("both","active"),":")
     frameStk:push(mname)
     mt = frameStk:mt()
     mt:add(mname,"pending")
     local status = loadModuleFile{file = fn, shell = shellNm, mList = mList, reportErr = true}

     -- Now fn is loaded mark active and run load hook then cleanup
  end

* We are ready to go to loadModuleFile(t)
** Note that we passed an anonymous table in Master.lua.   
** The result is that there is a single argument "t" to the function.
* function loadModuleFile(t)

* Once the loadModuleFile function returns
** We must mark the module as active and cleanup
* 





     -- Now fn is loaded 

     mt = frameStk:mt()

     -- A modulefile could the same named module over top of the current modulefile
     -- Say modulefile abc/2.0 loads abc/.cpu/2.0.  Then in the case of abc/2.0 the filename
     -- won't match.
     if (mt:fn(sn) == fn and status) then
        mt:setStatus(sn, "active")
        hook.apply("load",{fn = mname:fn(), modFullName = mname:fullName(), mname = mname})
     end
     frameStk:pop()
     loaded = true
